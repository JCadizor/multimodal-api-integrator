import { Alert } from 'react-native';
import { retrieveAsyncStorageDataAsJson } from './utils.js';
import { fetch } from 'expo/fetch';
import { log, errorlog, warn } from './simpleLogger.js';

/**
 * Classe para intera√ß√£o com a API REST de Assiduidade
 * Baseada no manual FLASK_API_INTEGRATION_MANUAL
 */
class AttendanceAPI {
  constructor() {
    this.baseUrl = 'https://flask-attendance-api-ymvx.onrender.com';
    this.apiKey = 'desenvolvimento_key_123';
    this.headers = {
      'X-API-KEY': this.apiKey,
      'Content-Type': 'application/json'
    };
  }


  /**
   * Configurar API com dados personalizados do utilizador
   */
  async configure() {
    try {
      const userData = await retrieveAsyncStorageDataAsJson();
      if (userData && userData.attendanceApiKey) {
        this.apiKey = userData.attendanceApiKey;
        this.headers['X-API-KEY'] = this.apiKey;
      }
      if (userData && userData.attendanceBaseUrl) {
        this.baseUrl = userData.attendanceBaseUrl;
      }
      log(`[attendanceAPI.js] üì° API de Assiduidade configurada:`, this.baseUrl);
    } catch (error) {
      warn(`[attendanceAPI.js] ‚ö†Ô∏è Usando configura√ß√µes padr√£o da API de Assiduidade`);
    }
  }

  /**
   * Verificar status da API
   */
  async checkStatus() {
    try {
      const response = await fetch(`${this.baseUrl}/`, {
        method: 'GET'
      });
      const data = await response.json();
      return { success: true, data };
    } catch (error) {
      errorlog(`[attendanceAPI.js] ‚ùå Erro ao verificar status da API:`, error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Obter informa√ß√µes de autentica√ß√£o
   */
  async getAuthInfo() {
    try {
      const response = await fetch(`${this.baseUrl}/auth-info`, {
        method: 'GET'
      });
      const data = await response.json();
      return { success: true, data };
    } catch (error) {
      errorlog(`[attendanceAPI.js] ‚ùå Erro ao obter info de autentica√ß√£o:`, error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Obter registos de assiduidade
   * @param {string} name - Nome do colaborador (opcional)
   * @param {string} date - Data no formato YYYY-MM-DD (opcional)
   */
  async getAttendance(name = null, date = null) {
    try {
      await this.configure();
      
      const params = new URLSearchParams();
      if (name) params.append('name', name);
      if (date) params.append('date', date);
      
      const url = `${this.baseUrl}/attendance${params.toString() ? '?' + params.toString() : ''}`;
      log(`[attendanceAPI.js] URL a ser chamada:`, url);
      const response = await fetch(url, {
        method: 'GET',
        headers: this.headers
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const data = await response.json();
      log(`[attendanceAPI.js] ‚úÖ Registos de assiduidade obtidos:`, data);
      return { success: true, data };

    } catch (error) {
      errorlog(`[attendanceAPI.js] ‚ùå Erro ao obter registos:`, error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Criar novo registo de assiduidade
   * @param {Object} attendanceData - Dados do registo
   */
  async createAttendance(attendanceData) {
    try {
      await this.configure();
      
      // Valida√ß√£o dos dados obrigat√≥rios
      if (!attendanceData.name || !attendanceData.date) {
        throw new Error('Nome e data s√£o obrigat√≥rios');
      }

      const response = await fetch(`${this.baseUrl}/attendance`, {
        method: 'POST',
        headers: this.headers,
        body: JSON.stringify(attendanceData)
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || `HTTP ${response.status}`);
      }

      const data = await response.json();
      log(`[attendanceAPI.js] ‚úÖ Registo criado com sucesso:`, data);
      return { success: true, data };

    } catch (error) {
      errorlog(`[attendanceAPI.js] ‚ùå Erro ao criar registo:`, error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Obter registo espec√≠fico por ID
   * @param {number} id - ID do registo
   */
  async getAttendanceById(id) {
    try {
      await this.configure();
      
      const response = await fetch(`${this.baseUrl}/attendance/${id}`, {
        method: 'GET',
        headers: this.headers
      });

      if (!response.ok) {
        if (response.status === 404) {
          throw new Error('Registo n√£o encontrado');
        }
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const data = await response.json();
      log(`[attendanceAPI.js] ‚úÖ Registo obtido:`, data);
      return { success: true, data };

    } catch (error) {
      errorlog(`[attendanceAPI.js] ‚ùå Erro ao obter registo por ID:`, error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Obter hist√≥rico de registos por colaborador
   * @param {string} name - Nome do colaborador
   * @param {number} limit - N√∫mero m√°ximo de registos (padr√£o: 10)
   */
  async getHistory(name, limit = 10) {
    try {
      await this.configure();
      
      if (!name) {
        throw new Error('Nome do colaborador √© obrigat√≥rio');
      }

      const params = new URLSearchParams({
        name: name,
        limit: limit.toString()
      });

      const response = await fetch(`${this.baseUrl}/attendance/history?${params}`, {
        method: 'GET',
        headers: this.headers
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const data = await response.json();
      log(`[attendanceAPI.js] ‚úÖ Hist√≥rico obtido:`, data);
      return { success: true, data };

    } catch (error) {
      errorlog(`[attendanceAPI.js] ‚ùå Erro ao obter hist√≥rico:`, error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Verificar se um colaborador j√° entrou hoje
   * @param {string} employeeName - Nome do colaborador
   */
  async checkEmployeeEntryToday(employeeName) {
    try {
      const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
      const result = await this.getAttendance(employeeName, today);
      
      if (!result.success) {
        return { success: false, error: result.error };
      }

      const records = result.data;
      
      if (records.length > 0 && records[0].time_entry) {
        const message = `Sim ‚Äî o ${employeeName} entrou hoje √†s ${records[0].time_entry}.`;
        return { 
          success: true, 
          hasEntered: true, 
          message: message,
          entryTime: records[0].time_entry,
          record: records[0]
        };
      } else {
        const message = `Hoje o ${employeeName} ainda n√£o entrou na empresa.`;
        return { 
          success: true, 
          hasEntered: false, 
          message: message 
        };
      }

    } catch (error) {
      errorlog(`[attendanceAPI.js] ‚ùå Erro ao verificar entrada do colaborador:`, error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Registar entrada de colaborador
   * @param {string} name - Nome do colaborador
   * @param {string} location - Local (opcional)
   */
  async recordEntry(name, location = null) {
    try {
      const now = new Date();
      const date = now.toISOString().split('T')[0]; // YYYY-MM-DD
      const time = now.toTimeString().split(' ')[0]; // HH:MM:SS

      const attendanceData = {
        name: name,
        date: date,
        time_entry: time
      };

      if (location) {
        attendanceData.location = location;
      }

      return await this.createAttendance(attendanceData);

    } catch (error) {
      errorlog(`[attendanceAPI.js] ‚ùå Erro ao registar entrada:`, error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Processar query em linguagem natural sobre assiduidade
   * @param {string} query - Pergunta do utilizador
   */
  async processNaturalQuery(query) {
    try {
      // An√°lise simples de padr√µes na query
      const lowerQuery = query.toLowerCase();
      
      // Padr√£o: "colaborador X j√° entrou hoje?"
      const entryPattern = /(.+?)\s+(j√°\s+entrou|entrou)\s+(hoje|hoj)/i;
      const entryMatch = query.match(entryPattern);
      
      if (entryMatch) {
        const employeeName = entryMatch[1].trim();
        return await this.checkEmployeeEntryToday(employeeName);
      }

      // Padr√£o: "hist√≥rico do colaborador X"
      const historyPattern = /(hist√≥rico|historia)\s+(do|da)?\s*(.+)/i;
      const historyMatch = query.match(historyPattern);
      
      if (historyMatch) {
        const employeeName = historyMatch[3].trim();
        return await this.getHistory(employeeName);
      }

      // Padr√£o: "registos de hoje"
      if (lowerQuery.includes('registos') && lowerQuery.includes('hoje')) {
        const today = new Date().toISOString().split('T')[0];
        return await this.getAttendance(null, today);
      }

      // Padr√£o gen√©rico - listar todos os registos
      if (lowerQuery.includes('listar') || lowerQuery.includes('todos')) {
        return await this.getAttendance();
      }

      return {
        success: false,
        error: 'N√£o consegui entender a pergunta. Experimente perguntas como: "Jo√£o j√° entrou hoje?" ou "hist√≥rico do Jo√£o"'
      };

    } catch (error) {
      errorlog(`[attendanceAPI.js] ‚ùå Erro ao processar query natural:`, error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Formatar resposta para apresenta√ß√£o ao utilizador
   * @param {Object} result - Resultado da API
   * @param {string} queryType - Tipo de consulta
   */
  formatResponse(result, queryType = 'general') {
    if (!result.success) {
      return `Erro: ${result.error}`;
    }

    switch (queryType) {
      case 'entry_check':
        return result.message;
      
      case 'history':
        if (result.data && result.data.length > 0) {
          const records = result.data.slice(0, 5); // Mostrar apenas os primeiros 5
          let response = `√öltimos registos:\n`;
          records.forEach(record => {
            response += `üìÖ ${record.date} - Entrada: ${record.time_entry || 'N/A'}`;
            if (record.time_exit) response += ` - Sa√≠da: ${record.time_exit}`;
            if (record.location) response += ` - Local: ${record.location}`;
            response += '\n';
          });
          return response;
        } else {
          return 'Nenhum registo encontrado.';
        }
      
      case 'list':
        if (result.data && result.data.length > 0) {
          const records = result.data.slice(0, 3); // Mostrar apenas os primeiros 3
          let response = `Registos encontrados (${result.data.length}):\n`;
          records.forEach(record => {
            response += `üë§ ${record.name} - ${record.date}`;
            if (record.time_entry) response += ` √†s ${record.time_entry}`;
            response += '\n';
          });
          if (result.data.length > 3) {
            response += `... e mais ${result.data.length - 3} registos.`;
          }
          return response;
        } else {
          return 'Nenhum registo encontrado.';
        }
      
      default:
        return JSON.stringify(result.data, null, 2);
    }
  }
}

// Inst√¢ncia singleton da API
const attendanceAPI = new AttendanceAPI();

export default attendanceAPI;

// Exportar fun√ß√µes individuais para compatibilidade
export const checkEmployeeEntry = (name) => attendanceAPI.checkEmployeeEntryToday(name);
export const getAttendanceRecords = (name, date) => attendanceAPI.getAttendance(name, date);
export const createAttendanceRecord = (data) => attendanceAPI.createAttendance(data);
export const getEmployeeHistory = (name, limit) => attendanceAPI.getHistory(name, limit);
export const processAttendanceQuery = (query) => attendanceAPI.processNaturalQuery(query);
